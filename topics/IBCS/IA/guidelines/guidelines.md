---
title: "IA - Guidelines and Requirements"
permalink: /topics/IBCS/IA/guidelines/
---

# Internal Assessment Solution Guidelines and Requirements

The project is designed to showcase your abilities in algorithmic thinking, technical design, and problem-solving by tackling real-world issues. It‚Äôs not just about programming‚Äîit‚Äôs about developing a comprehensive software solution that meets the actual needs of a client.

**Real Client Interaction:**  
You‚Äôre expected to work with a real person (e.g., a teacher, parent, or another adult). This collaboration is crucial because the client must clearly communicate their needs and later evaluate the solution, which introduces a practical element to your assessment.

**Time Commitment:**  
Approximately 30 hours will be allocated in class, with additional time required on your part. This underscores the importance of effective time management and planning.

Your project will be evaluated based on planning, analysis, design, documentation, and especially the complexity and ingenuity of your programming. The focus is on building a well-thought-out solution rather than just a functional piece of code.

---

## Programming Language and Methodology

**Object-Oriented Programming (OOP):**  
Although you can use any programming language, the recommendation is to use OOP in Java. Using Java aligns with your IB DP Computer Science coursework and demonstrates your grasp of core programming concepts.

**Justification of Language Choice:**  
Regardless of the programming language you select, you must clearly articulate why it is the most suitable choice for your project. Provide a detailed comparison of its advantages and disadvantages in relation to the project‚Äôs requirements.

---

## Research on Alternative Approaches and Rationale

Before finalizing your solution, you are required to research and consider various alternative approaches that might address your client‚Äôs needs. In your research, examine factors such as:

- **Integration:** Evaluate whether relying on multiple, disjointed applications or using a mix of manual and software processes might reduce efficiency compared to an integrated solution.
- **Cost:** Consider if some alternatives require expensive software licenses, subscriptions, or hardware investments that may not be sustainable (or feasible) within your client‚Äôs budget.
- **Complexity and Relevance:** Assess whether alternative solutions include unnecessary or overly complex features that do not directly align with your client‚Äôs specific needs, potentially overwhelming the end user.
- **Technical Feasibility:** Determine if other approaches are compatible (or feasible) with the existing technical and organizational infrastructure, including considerations such as access rights, data security, and long-term maintenance.
- **Other Factors:** Reflect on aspects such as scalability, ease of use, vendor dependency, and future upgrade potential.

After evaluating these points, provide a well-supported rationale explaining why your chosen solution is the best option. Your justification should address:

- How the alternative approaches fell short in meeting your client‚Äôs requirements.
- The advantages of your solution in terms of cost-effectiveness, usability, technical compatibility (or feasibility), and security.
- The evidence and reasoning that support your chosen solution.

---

## Source Documentation and Citation

To ensure originality and maintain academic integrity, it is essential that you keep a detailed record of all resources you use throughout your project. This includes, but is not limited to:

- Published papers or articles on algorithms.
- Video tutorials (e.g., from YouTube) and online courses.
- Imported Java packages and libraries.
- Code snippets, algorithms, or frameworks adopted from other sources.
- Technical blogs, forum posts, or Stack Overflow discussions.
- API documentation or software manuals.
- Textbooks, white papers, or online articles.
- Online sources and product reviews used to research and compare alternative solutions.

You are required to create proper citations for about 10 distinct sources within your IA documentation, especially in the final section of Criterion C. Accurate attribution of sources is critical to demonstrating your research diligence and upholding academic integrity.


---

## Suggestions for the Product

### Example Core Features

- **Graphical User Interface (GUI) with Multiple Windows:** Develop an interface that supports several windows, each handling different functionalities and tasks.
- **File Import/Export:** Allow users to import and export data using text or CSV files through a file selector window for ease of use.
- **Sorting Algorithms:** Integrate various sorting techniques to organize data effectively.
- **Searching/Filtering Capabilities:** Include both basic and advanced search/filter functionalities to enable efficient data lookup.
- **Data Structures and Abstract Data Types (ADTs):**  
  - Utilize arrays, 2D arrays, and ArrayLists for data storage.  
  - Incorporate advanced ADTs such as stacks, queues, binary trees, hashmaps, etc., to manage complex data sets.
- **Error Handling:** Implement robust error handling mechanisms to gracefully manage exceptions and unexpected inputs.
- **Usability Features:** Design user-friendly features that enhance overall usability, including clear instructions, responsive feedback, and accessibility considerations.
- **Data Presentation:** Use organized data tables to display information clearly for both viewing and manipulation.
- **Modular Programming with Multiple Java Classes:** Structure your code into multiple classes with reusable or generalized methods to promote maintainability and scalability.
- **Complex Data Manipulations:** Demonstrate multi-process data manipulations involving various logical conditions and method outputs to showcase advanced computational thinking.

### Incorporation of Researched-Based Algorithms

- **Greedy Algorithms:** For problems requiring locally optimal choices.
- **Genetic Algorithms:** Useful for evolving solutions in optimization problems.
- **Gale‚ÄìShapley Algorithm:** For grouping or pairing scenarios.
- **Shortest Path Finding Algorithms:** Such as Dijkstra or A*, to determine optimal routes.
- **Dynamic Programming:** Examples include the Knapsack problem or longest common subsequence to solve overlapping subproblems.
- **Divide and Conquer Algorithms:** Merge sort and quick sort illustrate recursive approaches to problem solving.
- **Backtracking Algorithms:** Suitable for exhaustive search tasks like solving Sudoku or the N-Queens problem.
- **Simulated Annealing:** A probabilistic technique for approximating global optima in complex search spaces.
- **Branch and Bound:** Ideal for combinatorial optimization by systematically pruning the search space.

### Extensions and Additional Enhancements

- **Timer Functionality:** Include features to manage or track time during task execution.
- **Calendar Integration:** Add a calendar component to schedule events, deadlines, or manage tasks.
- **2D Graphing:** Implement 2D graphing to visually represent data trends and results.
- **Database Integration:** Enable persistent data storage and retrieval through database systems for scalability.
- **Auto-Emailing:** Integrate automated email notifications for reports, alerts, or other communication needs.
- **Encryption/Decryption:** Secure sensitive data using encryption and decryption techniques to ensure privacy.

### Example Project Ideas

- **Inventory Control System:** A system for managing stock levels that includes features like file import/export, error handling, and email notifications for restocking.
- **Academic or Revision Game:** An interactive game designed to aid learning and revision, incorporating dynamic gameplay, modular coding, and complex algorithmic logic.
- **Task or Project Management Tool:** A comprehensive solution for scheduling, tracking, and managing tasks or projects, highlighting robust OOP design with multiple interacting classes.
- **Grouping or Scheduling Application:** An application that meets strict multiple conditions or restrictions, ideal for event planning or organizing team schedules.
- **Data Processing and Formatting Tool:** An application focused on intensive data processing, formatting, and reporting tasks with advanced file and database integration.
- **Data Analysis and Simulation Platform:** A system for analyzing trends, simulating scenarios, and making predictions based on complex data aggregation.
- **Interactive Turn-Based Strategy Game:**  
  - A game that emphasizes deep logical mechanics over rich graphics.
  - Features may include complex attributes for units (e.g., powers, counter elements, strengths, and weaknesses), strategic gameplay involving dynamic decision-making, and the integration of algorithms (such as A* for movement or genetic algorithms for adaptive AI).
- **Library Management System:** A classic OOP project ideal for Java, featuring modules for managing books, members, loans, and returns, with functionalities such as file handling, sorting/searching, and a GUI interface.
- **Financial or Hotel Reservation System:** Projects involving key aspects of OOP such as class inheritance (e.g., different account types, room categories), error handling, data management via files or databases, and complex business logic to simulate real-world processes.


‚ö†Ô∏èüö© Emphasis should be placed on genuine client need, original algorithmic work, and robust software design rather than relying on ready-made templates.

---

## Final Thoughts

This assessment is structured to not only evaluate your technical prowess but also your ability to plan, design, and communicate effectively with a real client. It is an opportunity to blend creativity, algorithmic complexity, and practical project management skills.  
By ensuring that your project is grounded in real-world requirements and challenges, you will be better prepared for both further academic pursuits and professional endeavors in software development.

Overall, these guidelines set a clear, challenging, and rewarding path‚Äîone that encourages deep thinking and comprehensive application of computer science principles. Approach the project with a clear plan and focus on quality and originality to gain valuable skills and experiences that extend well beyond the classroom.
